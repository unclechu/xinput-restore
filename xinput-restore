#!/bin/bash
#================================================================#
# Version : 0.2                                                  #
# Author  : Viacheslav Lotsmanov                                 #
# License : GNU/GPLv3 (https://www.gnu.org/licenses/gpl-3.0.txt) #
#================================================================#

[ "x$CONFIGS_PATH" == "x" ] && CONFIGS_PATH="$HOME/.xinput_configs"

mkdir -p "$CONFIGS_PATH"

trim () {
	while read line; do
		echo "$line" | sed -e "s/^\s\+\|\s\+$//g"
	done
}

# $1 - props
get-product-id () {
	
	local product_id=
}

# $1 - file name or device product id
get-props () {
	
	local props=
	local tmp_props=
	local found=false
	
	ls "$CONFIGS_PATH" | grep -F "$1" 1>/dev/null
	
	# when $1 is filename
	if [[ $? -eq 0 ]] && [[ -f "$1" ]]; then
		
		tmp_props=$(cat "$1")
		[ $? -ne 0 ] && { echo "Cannot read file '$1'." 1>&2; return 1; }
		
		found=true
		
	# when $1 is device product id
	else
		ls "$CONFIGS_PATH" | while read filename; do
			
			if [[ $found == false ]] || [[ ! -f "$filename" ]]; then
				continue
			fi
			
			tmp_props=$(cat "$filename")
			[ $? -ne 0 ] && { echo "Cannot read file '$1'." 1>&2; return 1; }
			
			found=true
		done
	fi
	
	if [ $found == true ]; then
		props=$tmp_props
	else
		# find by device product id
		ls "$CONFIGS_PATH" | while read filename; do
			# TODO
		done
	fi
	
	[ "x$props" == 'x' ] && { echo "Cannot get device props by '$1'." 1>&2; return 1; }
	
	echo "$props"
	return 0
}

# $1 - id of `xinput list`
# $2 (optional) - name of file
save () {
	
	echo "Saving xinput device properties by id '$1'..."
	
	local filename=
	local product_id=
	local props=
	
	# required arg validate
	[ "x$1" == "x" ] && { echo "No id of device." 1>&2; return 1; }
	
	# check in ids list
	xinput list --id-only | grep -Po "^$1$" > /dev/null 2>&1
	[ $? -ne 0 ] && { echo "Device not found by id '$1'." 1>&2; return 1; }
	
	# get all props to variable
	props=$(xinput list-props "$1")
	[ $? -ne 0 ] && { echo "Cannot get device props by id '$1'." 1>&2; return 1; }
	
	# parse device id prop
	product_id=$(echo "$props" | grep -i 'Device Product ID' | head -n1)
	[ $? -ne 0 ] && { echo "Cannot get device product id by id '$1'." 1>&2; return 1; }
	product_id=$(echo $product_id | sed 's/^.*\([^:]\+\)$/\1/g' | trim)
	[ $? -ne 0 ] && { echo "Cannot get device product id by id '$1'." 1>&2; return 1; }
	
	# get filename from args or from device name
	if [ "x$2" != "x" ]; then
		filename=$2
	else
		filename=$(echo "$props" | grep -i "^Device '" | head -n1)
		[ $? -ne 0 ] && { echo "Cannot get device name by id '$1'." 1>&2; return 1; }
		filename=$(echo "$filename" | sed -e "s/Device '\([^']\+\)'.*$/\1/g")
		[ $? -ne 0 ] && { echo "Cannot get device name by id '$1'." 1>&2; return 1; }
	fi
	
	# save properties to file
	xinput list-props "$1" > "$CONFIGS_PATH/$filename"
	[ $? -ne 0 ] && { echo "." 1>&2; return 1; }
	
	return 0
}

# $1 - file name or device product id
restore () {
	
	echo "Restoring xinput device properties by '$1'..."
	
	# required arg validate
	[ "x$1" == "x" ] && { echo "No id of device." 1>&2; return 1; }
	
	local props=$(get-props "$1")
	[ $? -ne 0 ] && { echo "Cannot restore device properties by '$1'."; return 1; }
	
	echo "$props" | while read prop; do
		
		local prop=$(echo "$prop" | sed 's/#.*$//g' | trim)
		[ "x$prop" == "x" ] && continue
		
		local prop_left_part=$(echo "$prop" | grep -io '^[a-z0-9 ]\+([0-9]\+):')
		if [[ $? -ne 0 ]] || [[ "x$prop_left_part" == "x" ]]; then
			continue
		fi
		
		local prop_num=$(echo "$prop_left_part" | grep -o '([0-9]\+)')
		prop_num=${prop_num:1:-1}
		
		local prop_val=$(echo "${prop:${#prop_left_part}}" | trim)
		if [[ $? -ne 0 ]] || [[ "x$prop_val" == "x" ]]; then
			continue
		fi
		
		xinput set-prop "$1" "$prop_num" "$prop_val" &>/dev/null
	done
	
	return 0
}

restore-all () {
	
	echo "Restoring xinput devices all configs..."
	
	ls "$CONFIGS_PATH" | while read file; do
		
		[ ! -f "$file" ] && continue
		
		restore "$file"
		if [ $? -ne 0 ]; then
			echo "Cannot restore device properties by file '$file'" 1>&2
			return 1
		fi
	done
	
	return 0
}

case "$1" in
	
	--save)
		if [ "x$3" != 'x' ]; then
			save "$2" "$3"
		else
			save "$2"
		fi
		exit $?
		;;
	
	--restore)
		restore "$2"
		exit $?
		;;
	
	--restore-all)
		restore-all
		exit $?
		;;
	
	'')
		restore-all
		exit $?
		;;
	
	*)
		echo "Unknown argument: '$1'" 1>&2
		exit 1
		;;
esac
